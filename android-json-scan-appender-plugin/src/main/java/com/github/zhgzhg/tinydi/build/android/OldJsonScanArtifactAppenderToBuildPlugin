package com.github.zhgzhg.tinydi.build.android;

import com.android.build.api.variant.impl.VariantOutputImpl;
import com.android.build.gradle.internal.tasks.MergeJavaResourceTask;
import com.android.build.gradle.tasks.MergeResources;
import com.android.build.gradle.tasks.MergeSourceSetFolders;
import com.android.build.gradle.tasks.PackageApplication;
import com.android.build.gradle.tasks.ResourceAwareTask;
import com.android.repository.Revision;
import com.android.repository.api.ProgressIndicator;
import com.android.sdklib.BuildToolInfo;
import com.android.sdklib.repository.AndroidSdkHandler;
import net.lingala.zip4j.ZipFile;
import com.github.zhgzhg.tinydi.build.BuildTimeScan;
import net.lingala.zip4j.model.ZipParameters;
import org.gradle.api.Action;
import org.gradle.api.DefaultTask;
import org.gradle.api.Plugin;
import org.gradle.api.Project;
import org.gradle.api.Task;
import org.gradle.api.file.FileCollection;
import org.gradle.api.provider.Property;
import org.gradle.api.tasks.TaskExecutionException;
import org.gradle.api.tasks.TaskInputs;
import org.gradle.api.tasks.compile.JavaCompile;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.ListIterator;
import java.util.concurrent.Executors;
import java.util.function.Consumer;
/*
abstract class MyProject implements Project {
    public BaseExtension android() {
        BaseExtension extension = this.getExtensions().findByType(BaseExtension.class);
        if (extension == null) {
            throw new GradleException("Project $name is not an Android project");
        }
        return extension;
    }
}

abstract class MyBaseExtension extends BaseExtension {
    public MyBaseExtension(@NotNull final DslServices dslServices, @NotNull final GlobalScope globalScope,
            @NotNull final NamedDomainObjectContainer<BaseVariantOutput> buildOutputs, @NotNull final SourceSetManager sourceSetManager,
            @NotNull final ExtraModelInfo extraModelInfo, final boolean isBaseModule) {
        super(dslServices, globalScope, buildOutputs, sourceSetManager, extraModelInfo, isBaseModule);
    }

    public DomainObjectSet<BaseVariant> variants() {
        //if (this instanceof AppExtension) {
        //    return ((AppExtension) this).getApplicationVariants();
        //}

        return null;
    }

}*/

public class JsonScanArtifactAppenderToBuildPlugin implements Plugin<Project> {

    public static abstract class JsonScanArtifactAppenderToBuildPluginExtension {
        public abstract Property<String> getAndroidSdkPath();
        public abstract Property<String> getAndroidBuildToolsVersion();
        public abstract Property<String[]> getScanArgs();

        public void androidSdkPath(Action<Property<String>> action) {
            action.execute(getAndroidSdkPath());
        }

        public void androidBuildToolsVersion(Action<Property<String>> action) {
            action.execute(getAndroidBuildToolsVersion());
        }

        public void scanArgs(Action<Property<String[]>> action) {
            action.execute(getScanArgs());
        }
    }

    /*private static Object getField(Class clazz, Object instance, String fieldName) {
        return Arrays.stream(clazz.getDeclaredFields())
                .filter(f -> fieldName.equals(f.getName()))
                .findFirst()
                .map(f -> {
                    try {
                        f.setAccessible(true);
                        return f.get(instance);
                    } catch(Exception ex) {
                        ex.printStackTrace(System.err);
                        return null;
                    }
                })
                .orElse(null);
    }*/

    private static class StreamGobbler implements Runnable {
        private InputStream inputStream;
        private Consumer<String> consumer;

        public StreamGobbler(InputStream inputStream, Consumer<String> consumer) {
            this.inputStream = inputStream;
            this.consumer = consumer;
        }

        @Override
        public void run() {
            new BufferedReader(new InputStreamReader(inputStream)).lines()
                    .forEach(consumer);
        }
    }

    private int execProcess(String[] execCmd) {
        try {
            Process process = Runtime.getRuntime().exec(execCmd);
            StreamGobbler streamGobbler = new StreamGobbler(process.getInputStream(), System.out::println);
            Executors.newSingleThreadExecutor().submit(streamGobbler);
            return process.waitFor();
        } catch (IOException | InterruptedException e) {
            e.printStackTrace(System.err);
        }
        return -99999;
    }

    private String computeScanFileName(JsonScanArtifactAppenderToBuildPluginExtension options) {
        String outputFile = "tinydi-scanresult.json";
        if (!options.getScanArgs().isPresent()) {
            return outputFile;
        }

        String[] args = options.getScanArgs().get();
        for (int i = args.length - 1; i > -1; --i) {
            if (args[i].startsWith("-of")) {
                outputFile = args[i].substring(3);
                break;
            }
        }

        return outputFile;
    }


    public void apply(Project project) {
        JsonScanArtifactAppenderToBuildPluginExtension options = project.getExtensions()
                .create("tinidiStaticJsonScanForAndroid", JsonScanArtifactAppenderToBuildPluginExtension.class);

        /*project.getTasks().register("helloWelt", DefaultTask.class, task -> {
            task.getOutputs().upToDateWhen(a -> false);
            task.getProject().defaultTasks("helloWelt");
            //task.getProject().getTasks().getByName("preBuild").dependsOn(task);
            task.dependsOn(task.getProject().getTasks().getByName("preBuild"));
            task.doLast(s -> System.out.println("NAI-NAKRAQ"));
        });*/

        project.getPluginManager().withPlugin("com.android.application", appliedPlugin -> {

            final Project proj = project;
            //proj.defaultTasks("generateScanJSON");

            proj.getLogger().info("TinyDI will be plugging into {} / {}", appliedPlugin.getName(), appliedPlugin.getName());

            proj.afterEvaluate(evaluatedProject -> {
                JavaCompile compileDebugJavaWithJavac = (JavaCompile) evaluatedProject.getTasks().getByName("compileDebugJavaWithJavac");
                MergeResources mergeDebugResources = (MergeResources) evaluatedProject.getTasks().getByName("mergeDebugResources");
                //MergeJavaResourceTask mergeDebugJavaResources = (MergeJavaResourceTask) evaluatedProject.getTasks().getByName("mergeDebugJavaResource");
                //Task generateDebugJavaResources = evaluatedProject.getTasks().getByName("generateDebugResources");
                //PackageApplication packageDebug = (PackageApplication) evaluatedProject.getTasks().getByName("packageDebug");
                //Task generateDebugAssets = evaluatedProject.getTasks().getByName("generateDebugAssets");

                File jsonArtifactOutputDir = new File(new File(compileDebugJavaWithJavac.getTemporaryDir(), "res"), "raw");
                String outputFile = computeScanFileName(options);

                MergeSourceSetFolders mergeSourceSetFolders = (MergeSourceSetFolders) evaluatedProject.getTasks().getByName("mergeDebugAssets");
                //mergeSourceSetFolders.getInputs().file(new File(jsonArtifactOutputDir, outputFile));
                //mergeSourceSetFolders.getSourceFolderInputs().setFrom(jsonArtifactOutputDir);

                compileDebugJavaWithJavac.doLast("Generate TinyDI's Static JSON Scan", s -> {
                    System.out.println("Generating static classpath scan as a JSON file...");

                    jsonArtifactOutputDir.mkdirs();

                    File destDir = compileDebugJavaWithJavac.getDestinationDirectory().get().getAsFile();

                    List<String> cliArgs = new ArrayList<>();
                    //cliArgs.add("-od" + jsonArtifactOutputDir.getAbsolutePath());
                    File outputDir = mergeSourceSetFolders.getSourceFolderInputs().getFiles().iterator().next();
                    cliArgs.add("-od" + outputDir.getAbsolutePath());
                    cliArgs.add("-oc" + destDir.getAbsolutePath());
                    cliArgs.addAll(Arrays.asList(options.getScanArgs().get()));

                    BuildTimeScan.main(cliArgs.toArray(new String[0]));


                    System.out.printf("Using android SDK path %s = %s%n", options.getAndroidSdkPath().toString(), options.getAndroidSdkPath().get());
                    AndroidSdkHandler sdkHandler = AndroidSdkHandler.getInstance(new File(options.getAndroidSdkPath().get()));

                    BuildToolInfo buildToolInfo;
                    if (options.getAndroidBuildToolsVersion().isPresent()) {
                        buildToolInfo = sdkHandler.getBuildToolInfo(
                                Revision.parseRevision(options.getAndroidBuildToolsVersion().get()), new DummyProgressIndicatorImpl());
                    } else {
                        buildToolInfo = sdkHandler.getLatestBuildTool(new DummyProgressIndicatorImpl(), true);
                    }

                    System.out.printf("Using android build tools %s%n", buildToolInfo.getRevision().toString());

                    String aapt2Path = buildToolInfo.getPath(BuildToolInfo.PathId.AAPT2);
                    String flatFileOutputDir = mergeDebugResources.getGeneratedResOutputDir().getAsPath() + File.separator;

                    String[] execCmd = new String[]{ aapt2Path, "compile", "-o", flatFileOutputDir,
                            new File(jsonArtifactOutputDir, outputFile).getAbsolutePath()
                    };
                    System.out.println(String.join(" ", execCmd));
                    int exitCode = execProcess(execCmd);
                    System.out.printf("Wrote compiled resource as a .flat file to %s, exit code %d", flatFileOutputDir, exitCode);
                    if (exitCode != 0) {
                        throw new TaskExecutionException(
                                s, new RuntimeException("TinyDI: AAPT2 compiler exited with code " + exitCode));
                    }


                    /*File staticScanJsonFlat = new File(flatFileOutputDir, String.format("raw_%s.flat", outputFile));
                    packageDebug.doLast(pd -> {
                        for (VariantOutputImpl variant : packageDebug.getVariantOutputs().get()) {
                            String outputFileName = variant.getOutputFileName().get();
                            File destinationApk = new File(packageDebug.getOutputDirectory().get().getAsFile(), outputFileName);

                            try (ZipFile zipFile = new ZipFile(destinationApk)) {
                                ZipParameters zipParams = new ZipParameters();
                                zipParams.setFileNameInZip("res" + File.separator + "raw" + File.separator + staticScanJsonFlat.getName());
                                zipFile.addFile(staticScanJsonFlat, zipParams);
                            } catch (Exception e) {
                                e.printStackTrace(System.err);
                            }
                        }
                    });*/
                });
            });
        });
    }

    public void apply2(Project project) {
        /*
        for (Plugin p : project.getPlugins()) {
            System.out.println(p.getClass().getCanonicalName());
        }

        AppPlugin plugin = project.getPlugins().findPlugin(AppPlugin.class);
        System.out.printf("PLugin %s%n", plugin != null);

        GlobalScope globalScope = (GlobalScope) getField(BasePlugin.class, plugin, "globalScope");

        System.out.printf("Scope %s%n", globalScope != null);

        BuildToolInfo buildToolInfo = globalScope
                .getVersionedSdkLoader()
                .get()
                .getBuildToolInfoProvider()
                .get();

        String aapt2Path = buildToolInfo.getPath(BuildToolInfo.PathId.AAPT2);*/
        /*AndroidSdkHandler.getInstance(new File())


        System.out.printf("AAAAAAAAAAAAAAAa1111: %s", project.getProperties());
        System.out.printf("AAAAAAAAAAAAAAAa2: %s", project.getExtensions().getExtraProperties().getProperties());
        System.out.printf("AAAAAAAAAAAAAAAa3: %s", project.getExtensions());

        BaseExtension byType = project.getExtensions().findByType(BaseExtension.class);

        System.out.printf("AAAAAAAAAAAAAAAa: %s", byType);

        DomainObjectSet<? extends BaseVariant> variants;

        if (byType instanceof AppExtension) {
            variants = ((AppExtension) byType).getApplicationVariants();
        } else if (byType instanceof LibraryExtension) {
            variants = ((LibraryExtension) byType).getLibraryVariants();
        } else if (byType instanceof TestExtension){
            variants = ((TestExtension) byType).getApplicationVariants();
        } else {
            variants = null;
        }

        for (BaseVariant variant : variants) {

            project.getTasks().create("appendStaticJsonScanForAndroid" + variant.getName(), task -> {
                task.setGroup("JsonScanArtifactAppenderTasks");
                task.doLast(s -> System.out.println("Hello from plugin 'a2.greeting'"));
            });

        }*/


        project.getPluginManager().apply("com.android.application");

        JsonScanArtifactAppenderToBuildPluginExtension options = project.getExtensions()
                .create("tinidiStaticJsonScanForAndroid", JsonScanArtifactAppenderToBuildPluginExtension.class);


        project.afterEvaluate(evaluatedProject -> {
            JavaCompile compileDebugJavaWithJavac = (JavaCompile) evaluatedProject.getTasks().getByName("compileDebugJavaWithJavac");

            evaluatedProject.getTasks().create("blabla", JavaCompile.class, task -> {
                task.dependsOn(compileDebugJavaWithJavac);
                task.doLast(s ->
                        System.out.println("AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"));
            });
        });


        //TaskExecutionGraph taskGraph = project.getGradle().getTaskGraph();
        //taskGraph = taskGraph;

        //Task generateScanJSON = project.getTasks().create("generateScanJSON", JavaCompile.class, task -> {
        //    task.setGroup("static json scan artifacts");
        //
        //    //JavaCompile compileTask = (JavaCompile) task.dependsOn("compileDebugJavaWithJavac");
        //    Task compileDebugJavaWithJavac = project.getTasks().getByName("compileDebugJavaWithJavac");
        //    compileDebugJavaWithJavac = compileDebugJavaWithJavac;
        //
        //    task.doLast(s -> {
        //        s.getLogger().info("Generating static classpath scan as a JSON file...");
        //
        //        File jsonArtifactOutputDir = new File(new File(compileTask.getTemporaryDir(), "res"), "raw");
        //        jsonArtifactOutputDir.mkdirs();
        //
        //        File destDir = compileTask.getDestinationDirectory().get().getAsFile();
        //
        //        List<String> cliArgs = new ArrayList<>();
        //        cliArgs.add("-od" + jsonArtifactOutputDir.getAbsolutePath());
        //        cliArgs.add("-oc" + destDir.getAbsolutePath());
        //        cliArgs.addAll(Arrays.asList(options.getScanArgs().get()));
        //
        //        BuildTimeScan.main(cliArgs.toArray(new String[0]));
        //    });
        //});

        /*project.getTasks().create("invokeAAPT2", Exec.class, task -> {

        });*/

        Task task1 = project.getTasks().create("appendStaticJsonScanForAndroid", task -> {
            task.setGroup("static json scan artifacts");
            task.dependsOn("generateScanJSON");

            task.doLast(s -> {

                System.out.printf("Using android SDK path %s%n", options.getAndroidSdkPath().toString());

                AndroidSdkHandler sdkHandler = AndroidSdkHandler.getInstance(
                        new File(options.getAndroidSdkPath().get())
                );

                BuildToolInfo buildToolInfo;
                if (options.getAndroidBuildToolsVersion().isPresent()) {
                    buildToolInfo = sdkHandler.getBuildToolInfo(
                            Revision.parseRevision(options.getAndroidBuildToolsVersion().get()), new DummyProgressIndicatorImpl());
                } else {
                    buildToolInfo = sdkHandler.getLatestBuildTool(new DummyProgressIndicatorImpl(), true);
                }

                System.out.printf("Using android build tools %s%n", buildToolInfo.getRevision().toString());

                String aapt2Path = buildToolInfo.getPath(BuildToolInfo.PathId.AAPT2);

                System.out.printf("AAPT2 path: %s%n", aapt2Path);


            });
        });
    }
}

class DummyProgressIndicatorImpl implements ProgressIndicator {

    @Override
    public void setText(final String s) {

    }

    @Override
    public boolean isCanceled() {
        return false;
    }

    @Override
    public void cancel() {

    }

    @Override
    public void setCancellable(final boolean cancellable) {

    }

    @Override
    public boolean isCancellable() {
        return false;
    }

    @Override
    public void setIndeterminate(final boolean indeterminate) {

    }

    @Override
    public boolean isIndeterminate() {
        return false;
    }

    @Override
    public void setFraction(final double v) {

    }

    @Override
    public double getFraction() {
        return 0;
    }

    @Override
    public void setSecondaryText(final String s) {

    }

    @Override
    public void logWarning(final String s) {

    }

    @Override
    public void logWarning(final String s, final Throwable e) {

    }

    @Override
    public void logError(final String s) {

    }

    @Override
    public void logError(final String s, final Throwable e) {

    }

    @Override
    public void logInfo(final String s) {

    }
}
